<h1>Ansible Provisioner</h1>

<p><strong>Provisioner name: <code>&quot;ansible&quot;</code></strong></p>

<p>The ansible provisioner allows you to provision the guest using
<a href="javascript:if(confirm(%27http://ansible.com/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://ansible.com/%27" tppabs="http://ansible.com/">Ansible</a> playbooks by executing <code>ansible-playbook</code> from the Vagrant host.</p>

<p>Ansible playbooks are <a href="javascript:if(confirm(%27http://en.wikipedia.org/wiki/YAML  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://en.wikipedia.org/wiki/YAML%27" tppabs="http://en.wikipedia.org/wiki/YAML">YAML</a> documents that
comprise the set of steps to be orchestrated on one or more machines. This documentation
page will not go into how to use Ansible or how to write Ansible playbooks, since Ansible
is a complete deployment and configuration management system that is beyond the scope of
a single page of documentation.</p>

<div class="alert alert-warn">
  <p>
    <strong>Warning:</strong> If you're not familiar with Ansible and Vagrant already,
    I recommend starting with the <a href="shell.html" tppabs="http://docs.vagrantup.com/v2/provisioning/shell.html">shell
    provisioner</a>. However, if you're comfortable with Vagrant already, Vagrant
    is a great way to learn Ansible.
  </p>
</div>

<h2>Setup Requirements</h2>

<ul>
<li><a href="javascript:if(confirm(%27http://docs.ansible.com/intro_installation.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/intro_installation.html#installing-the-control-machine%27" tppabs="http://docs.ansible.com/intro_installation.html#installing-the-control-machine">Install Ansible</a> on your Vagrant host.</li>
<li>Your Vagrant host should ideally provide a recent version of OpenSSH that <a href="javascript:if(confirm(%27http://docs.ansible.com/faq.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/faq.html#how-do-i-get-ansible-to-reuse-connections-enable-kerberized-ssh-or-have-ansible-pay-attention-to-my-local-ssh-config-file%27" tppabs="http://docs.ansible.com/faq.html#how-do-i-get-ansible-to-reuse-connections-enable-kerberized-ssh-or-have-ansible-pay-attention-to-my-local-ssh-config-file">supports ControlPersist</a></li>
</ul>

<h2>Inventory File</h2>

<p>When using Ansible, it needs to know on which machines a given playbook should run. It does
this by way of an <a href="javascript:if(confirm(%27http://docs.ansible.com/intro_inventory.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/intro_inventory.html%27" tppabs="http://docs.ansible.com/intro_inventory.html">inventory</a> file which lists those machines.
In the context of Vagrant, there are two ways to approach working with inventory files.</p>

<h3>Auto-Generated Inventory</h3>

<p>The first and simplest option is to not provide one to Vagrant at all. Vagrant will generate an
inventory file encompassing all of the virtual machines it manages, and use it for provisioning
machines. The generated inventory file is stored as part of your local Vagrant environment in <code>.vagrant/provisioners/ansible/inventory/vagrant_ansible_inventory</code>.</p>

<p><strong>Groups of Hosts</strong></p>

<p>The <code>ansible.groups</code> option can be used to pass a hash of group names and group members to be included in the generated inventory file.</p>

<p>With this configuration example:</p>

<pre><code>ansible.groups = {
  &quot;group1&quot; =&gt; [&quot;machine1&quot;],
  &quot;group2&quot; =&gt; [&quot;machine2&quot;],
  &quot;all_groups:children&quot; =&gt; [&quot;group1&quot;, &quot;group2&quot;]
}
</code></pre>

<p>Vagrant would generate an inventory file that might look like:</p>

<pre><code># Generated by Vagrant

machine1 ansible_ssh_host=127.0.0.1 ansible_ssh_port=2200
machine2 ansible_ssh_host=127.0.0.1 ansible_ssh_port=2201

[group1]
machine1

[group2]
machine2

[all_groups:children]
group1
group2
</code></pre>

<p><strong>Notes</strong></p>

<ul>
<li>The generation of group variables blocks (e.g. <code>[group1:vars]</code>) are intentionally not supported, as it is <a href="javascript:if(confirm(%27http://docs.ansible.com/intro_inventory.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/intro_inventory.html#splitting-out-host-and-group-specific-data%27" tppabs="http://docs.ansible.com/intro_inventory.html#splitting-out-host-and-group-specific-data">not recommended to store group variables in the main inventory file</a>. A good practice is to store these group (or host) variables in <code>YAML</code> files stored in <code>group_vars/</code> or <code>host_vars/</code> directories in the playbook (or inventory) directory.</li>
<li>Unmanaged machines and undefined groups are not added to the inventory, to avoid useless Ansible errors (e.g. <em>unreachable host</em> or <em>undefined child group</em>)</li>
</ul>

<p>For example, <code>machine3</code>, <code>group3</code> and <code>group1:vars</code> in the example below would not be added to the generated inventory file:</p>

<pre><code>ansible.groups = {
  &quot;group1&quot; =&gt; [&quot;machine1&quot;],
  &quot;group2&quot; =&gt; [&quot;machine2&quot;, &quot;machine3&quot;],
  &quot;all_groups:children&quot; =&gt; [&quot;group1&quot;, &quot;group2&quot;, &quot;group3&quot;],
  &quot;group1:vars&quot; =&gt; { &quot;variable1&quot; =&gt; 9, &quot;variable2&quot; =&gt; &quot;example&quot; }
}
</code></pre>

<h3>Static Inventory</h3>

<p>The second option is for situations where you&#39;d like to have more control over the inventory management.
With the <code>ansible.inventory_path</code> option, you can reference a specific inventory resource (e.g. a static inventory file, a <a href="javascript:if(confirm(%27http://docs.ansible.com/intro_dynamic_inventory.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/intro_dynamic_inventory.html%27" tppabs="http://docs.ansible.com/intro_dynamic_inventory.html">dynamic inventory script</a> or even <a href="javascript:if(confirm(%27http://docs.ansible.com/intro_dynamic_inventory.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/intro_dynamic_inventory.html#using-multiple-inventory-sources%27" tppabs="http://docs.ansible.com/intro_dynamic_inventory.html#using-multiple-inventory-sources">multiple inventories stored in the same directory</a>). Vagrant will then use this inventory information instead of generating it.</p>

<p>A very simple inventory file for use with Vagrant might look like:</p>

<pre><code>default ansible_ssh_host=192.168.111.222
</code></pre>

<p>Where the above IP address is one set in your Vagrantfile:</p>

<pre><code>config.vm.network :private_network, ip: &quot;192.168.111.222&quot;
</code></pre>

<p><strong>Notes:</strong></p>

<ul>
<li>The machine names in <code>Vagrantfile</code> and <code>ansible.inventory_path</code> files should correspond, unless you use <code>ansible.limit</code> option to reference the correct machines.</li>
<li>The SSH host addresses (and ports) must obviously be specified twice, in <code>Vagrantfile</code> and <code>ansible.inventory_path</code> files.</li>
</ul>

<h2>Playbook</h2>

<p>The second component of a successful Ansible provisioner setup is the Ansible playbook
which contains the steps that should be run on the guest. Ansible&#39;s
<a href="javascript:if(confirm(%27http://docs.ansible.com/playbooks.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/playbooks.html%27" tppabs="http://docs.ansible.com/playbooks.html">playbook documentation</a> goes into great
detail on how to author playbooks, and there are a number of
<a href="javascript:if(confirm(%27http://docs.ansible.com/playbooks_best_practices.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/playbooks_best_practices.html%27" tppabs="http://docs.ansible.com/playbooks_best_practices.html">best practices</a> that can be applied to use
Ansible&#39;s powerful features effectively. A playbook that installs and starts (or restarts
if it was updated) the NTP daemon via YUM looks like:</p>

<pre><code>---
- hosts: all
  tasks:
    - name: ensure ntpd is at the latest version
      yum: pkg=ntp state=latest
      notify:
      - restart ntpd
  handlers:
    - name: restart ntpd
      service: name=ntpd state=restarted
</code></pre>

<p>You can of course target other operating systems that don&#39;t have YUM by changing the
playbook tasks. Ansible ships with a number of <a href="javascript:if(confirm(%27http://docs.ansible.com/modules.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/modules.html%27" tppabs="http://docs.ansible.com/modules.html">modules</a>
that make running otherwise tedious tasks dead simple.</p>

<h2>Running Ansible</h2>

<p>To run Ansible against your Vagrant guest, the basic Vagrantfile configuration looks like:</p>

<pre><code class="ruby">Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.provision &quot;ansible&quot; do |ansible|
    ansible.playbook = &quot;playbook.yml&quot;
  end
end
</code></pre>

<p>Since an Ansible playbook can include many files, you may also collect the related files in
a directory structure like this:</p>

<pre><code>$ tree
.
|-- Vagrantfile
|-- provisioning
|   |-- group_vars
|           |-- all
|   |-- playbook.yml
</code></pre>

<p>In such an arrangement, the <code>ansible.playbook</code> path should be adjusted accordingly:</p>

<pre><code class="ruby">Vagrant.configure(&quot;2&quot;) do |config|
  config.vm.provision &quot;ansible&quot; do |ansible|
    ansible.playbook = &quot;provisioning/playbook.yml&quot;
  end
end
</code></pre>

<p>Vagrant will try to run the <code>playbook.yml</code> playbook against all machines defined in your Vagrantfile.</p>

<p><strong>Backward Compatibility Note</strong>:</p>

<p>Up to Vagrant 1.4, the Ansible provisioner could potentially connect (multiple times) to all hosts from the inventory file.
This behaviour is still possible by setting <code>ansible.limit = &#39;all&#39;</code> (see more details below).</p>

<h2>Additional Options</h2>

<p>The Ansible provisioner also includes a number of additional options that can be set,
all of which get passed to the <code>ansible-playbook</code> command that ships with Ansible.</p>

<ul>
<li><p><code>ansible.extra_vars</code> can be used to pass additional variables (with highest priority) to the playbook. This parameter can be a path to a JSON or YAML file, or a hash. For example:</p>

<pre><code>ansible.extra_vars = {
  ntp_server: &quot;pool.ntp.org&quot;,
  nginx: {
    port: 8008,
    workers: 4
  }
}
</code></pre>

<p>These variables take the highest precedence over any other variables.</p></li>
<li><p><code>ansible.sudo</code> can be set to <code>true</code> to cause Ansible to perform commands using sudo.</p></li>
<li><p><code>ansible.sudo_user</code> can be set to a string containing a username on the guest who should be used
by the sudo command.</p></li>
<li><p><code>ansible.ask_sudo_pass</code> can be set to <code>true</code> to require Ansible to prompt for a sudo password.</p></li>
<li><p><code>ansible.ask_vault_pass</code> can be set to <code>true</code> to require Ansible to prompt for a vault password.</p></li>
<li><p><code>ansible.vault_password_file</code> can be set to a string containing the path of a file containing the password used by Ansible Vault.</p></li>
<li><p><code>ansible.limit</code> can be set to a string or an array of machines or groups from the inventory file to further control which hosts are affected. Note that:</p>

<ul>
<li>As of Vagrant 1.5, the machine name (taken from Vagrantfile) is set as <strong>default limit</strong> to ensure that <code>vagrant provision</code> steps only affect the expected machine. Setting <code>ansible.limit</code> will override this default.</li>
<li>Setting <code>ansible.limit = &#39;all&#39;</code> can be used to make Ansible connect to all machines from the inventory file.</li>
</ul></li>
<li><p><code>ansible.verbose</code> can be set to increase Ansible&#39;s verbosity to obtain detailed logging:</p>

<ul>
<li><code>&#39;v&#39;</code>, verbose mode</li>
<li><code>&#39;vv&#39;</code></li>
<li><code>&#39;vvv&#39;</code>, more</li>
<li><code>&#39;vvvv&#39;</code>, connection debugging</li>
</ul></li>
<li><p><code>ansible.tags</code> can be set to a string or an array of tags. Only plays, roles and tasks tagged with these values will be executed.</p></li>
<li><p><code>ansible.skip_tags</code> can be set to a string or an array of tags. Only plays, roles and tasks that <em>do not match</em> these values will be executed.</p></li>
<li><p><code>ansible.start_at_task</code> can be set to a string corresponding to the task name where the playbook provision will start.</p></li>
<li><p><code>ansible.raw_arguments</code> can be set to an array of strings corresponding to a list of <code>ansible-playbook</code> arguments (e.g. <code>[&#39;--check&#39;, &#39;-M /my/modules&#39;]</code>). It is an <em>unsafe wildcard</em> that can be used to apply Ansible options that are not (yet) supported by this Vagrant provisioner. As of Vagrant 1.7, <code>raw_arguments</code> has the highest priority and its values can potentially override or break other Vagrant settings.</p></li>
<li><p><code>ansible.raw_ssh_args</code> can be set to an array of strings corresponding to a list of OpenSSH client parameters (e.g. <code>[&#39;-o ControlMaster=no&#39;]</code>). It is an <em>unsafe wildcard</em> that can be used to pass additional SSH settings to Ansible via <code>ANSIBLE_SSH_ARGS</code> environment variable.</p></li>
<li><p><code>ansible.host_key_checking</code> can be set to <code>true</code> which will enable host key checking. As of Vagrant 1.5, the default value is <code>false</code> and as of Vagrant 1.7 the user kownn host file (e.g. <code>~/.ssh/known_hosts</code>) is no longer read nor modified. In other words: by default, the Ansible provisioner behaves the same as Vagrant native commands (e.g <code>vagrant ssh</code>).</p></li>
</ul>

<h2>Tips and Tricks</h2>

<h3>Ansible Parallel Execution</h3>

<p>Vagrant is designed to provision <a href="../multi-machine.html" tppabs="http://docs.vagrantup.com/v2/multi-machine">multi-machine environments</a> in sequence, but the following configuration pattern can be used to take advantage of Ansible parallelism:</p>

<pre><code>  # By default, Vagrant 1.7+ automatically inserts a different
  # insecure keypair for each new VM created. The easiest way
  # to use the same keypair for all the machines is to disable
  # this feature and rely on the legacy insecure key.
  config.ssh.insert_key = false

  config.vm.define &#39;machine2&#39; do |machine|
    machine.vm.hostname = &#39;machine2&#39;
    machine.vm.network &quot;private_network&quot;, ip: &quot;192.168.77.22&quot;
  end

  config.vm.define &#39;machine1&#39; do |machine|
    machine.vm.hostname = &#39;machine1&#39;
    machine.vm.network &quot;private_network&quot;, ip: &quot;192.168.77.21&quot;

    machine.vm.provision :ansible do |ansible|
      ansible.playbook = &quot;playbook.yml&quot;

      # Disable default limit (required with Vagrant 1.5+)
      ansible.limit = &#39;all&#39;
    end
  end
</code></pre>

<h3>Provide a local <code>ansible.cfg</code> file</h3>

<p>Certain settings in Ansible are (only) adjustable via a <a href="javascript:if(confirm(%27http://docs.ansible.com/intro_configuration.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/intro_configuration.html%27" tppabs="http://docs.ansible.com/intro_configuration.html">configuration file</a>, and you might want to ship such a file in your Vagrant project.</p>

<p>As <code>ansible-playbook</code> command looks for local <code>ansible.cfg</code> configuration file in its <em>current directory</em> (but not in the directory that contains the main playbook), you have to store this file adjacent to your Vagrantfile.</p>

<p>Note that it is also possible to reference an Ansible configuration file via <code>ANSIBLE_CONFIG</code> environment variable, if you want to be flexible about the location of this file.</p>

<h3>Why does the Ansible provisioner connect as the wrong user?</h3>

<p>It is good to know that the following Ansible settings always override the <code>config.ssh.username</code> option defined in <a href="../vagrantfile/ssh_settings.html" tppabs="http://docs.vagrantup.com/v2/vagrantfile/ssh_settings.html">Vagrant SSH Settings</a>:</p>

<ul>
<li><code>ansible_ssh_user</code> variable</li>
<li><code>remote_user</code> (or <code>user</code>) play attribute</li>
<li><code>remote_user</code> task attribute</li>
</ul>

<p>Be aware that copying snippets from the Ansible documentation might lead to this problem, as <code>root</code> is used as the remote user in many <a href="javascript:if(confirm(%27http://docs.ansible.com/playbooks_intro.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://docs.ansible.com/playbooks_intro.html#hosts-and-users%27" tppabs="http://docs.ansible.com/playbooks_intro.html#hosts-and-users">examples</a>.</p>

<p>Example of an SSH error (with <code>vvv</code> log level), where an undefined remote user <code>xyz</code> has replaced <code>vagrant</code>:</p>

<pre><code>TASK: [my_role | do something] *****************
&lt;127.0.0.1&gt; ESTABLISH CONNECTION FOR USER: xyz
&lt;127.0.0.1&gt; EXEC [&#39;ssh&#39;, &#39;-tt&#39;, &#39;-vvv&#39;, &#39;-o&#39;, &#39;ControlMaster=auto&#39;,...
fatal: [ansible-devbox] =&gt; SSH encountered an unknown error. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue.
</code></pre>

<p>In a situation like the above, to override the <code>remote_user</code> specified in a play you can use the following line in your Vagrantfile <code>vm.provision</code> block:</p>

<pre><code>ansible.extra_vars = { ansible_ssh_user: &#39;vagrant&#39; }
</code></pre>